

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>FlowCal.mef module &mdash; FlowCal 1.1.4 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/my_style.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="FlowCal 1.1.4 documentation" href="../index.html"/>
        <link rel="up" title="FlowCal (Python API) Reference" href="modules.html"/>
        <link rel="next" title="FlowCal.plot module" href="FlowCal.plot.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> FlowCal
          

          
          </a>

          
            
            
              <div class="version">
                1.1.4
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../getting_started/index.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fundamentals/index.html">Fundamentals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../excel_ui/index.html">FlowCal&#8217;s Excel UI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python_tutorial/index.html">FlowCal&#8217;s Python API Tutorial</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">FlowCal (Python API) Reference</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="FlowCal.excel_ui.html">FlowCal.excel_ui module</a></li>
<li class="toctree-l2"><a class="reference internal" href="FlowCal.gate.html">FlowCal.gate module</a></li>
<li class="toctree-l2"><a class="reference internal" href="FlowCal.io.html">FlowCal.io module</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">FlowCal.mef module</a></li>
<li class="toctree-l2"><a class="reference internal" href="FlowCal.plot.html">FlowCal.plot module</a></li>
<li class="toctree-l2"><a class="reference internal" href="FlowCal.stats.html">FlowCal.stats module</a></li>
<li class="toctree-l2"><a class="reference internal" href="FlowCal.transform.html">FlowCal.transform module</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../contribute/index.html">Contribute</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">FlowCal</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="modules.html">FlowCal (Python API) Reference</a> &raquo;</li>
        
      <li>FlowCal.mef module</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/reference/FlowCal.mef.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-FlowCal.mef">
<span id="flowcal-mef-module"></span><h1>FlowCal.mef module<a class="headerlink" href="#module-FlowCal.mef" title="Permalink to this headline">¶</a></h1>
<p>Functions for transforming flow cytometer data to MEF units.</p>
<dl class="function">
<dt id="FlowCal.mef.clustering_gmm">
<code class="descclassname">FlowCal.mef.</code><code class="descname">clustering_gmm</code><span class="sig-paren">(</span><em>data</em>, <em>n_clusters</em>, <em>tol=1e-07</em>, <em>min_covar=5e-05</em>, <em>scale='logicle'</em><span class="sig-paren">)</span><a class="headerlink" href="#FlowCal.mef.clustering_gmm" title="Permalink to this definition">¶</a></dt>
<dd><p>Find clusters in an array using Gaussian Mixture Models (GMM).</p>
<p>Before clustering, <cite>data</cite> can be automatically rescaled as specified by
the <cite>scale</cite> argument.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : FCSData or array_like</p>
<blockquote>
<div><p>Data to cluster.</p>
</div></blockquote>
<p><strong>n_clusters</strong> : int</p>
<blockquote>
<div><p>Number of clusters to find.</p>
</div></blockquote>
<p><strong>tol</strong> : float, optional</p>
<blockquote>
<div><p>Tolerance for convergence of GMM method. Passed directly to
<code class="docutils literal"><span class="pre">scikit-learn</span></code>&#8216;s GMM.</p>
</div></blockquote>
<p><strong>min_covar</strong> : float, optional</p>
<blockquote>
<div><p>Minimum covariance. Passed directly to <code class="docutils literal"><span class="pre">scikit-learn</span></code>&#8216;s GMM.</p>
</div></blockquote>
<p><strong>scale</strong> : str, optional</p>
<blockquote>
<div><p>Rescaling applied to <cite>data</cite> before performing clustering. Can be
either <code class="docutils literal"><span class="pre">linear</span></code> (no rescaling), <code class="docutils literal"><span class="pre">log</span></code>, or <code class="docutils literal"><span class="pre">logicle</span></code>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>labels</strong> : array</p>
<blockquote class="last">
<div><p>Nx1 array with labels for each element in <cite>data</cite>, assigning
<code class="docutils literal"><span class="pre">data[i]</span></code> to cluster <code class="docutils literal"><span class="pre">labels[i]</span></code>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>GMM finds clusters by fitting a linear combination of <cite>n_clusters</cite>
Gaussian probability density functions (pdf) to <cite>data</cite> using
Expectation Maximization (EM).</p>
<p>GMM can be fairly sensitive to the initial parameter choice. To
generate a reasonable set of initial conditions, <cite>clustering_gmm</cite>
first divides all points in <cite>data</cite> into <cite>n_clusters</cite> groups of the
same size based on their Euclidean distance to the minimum value. Then,
for each group, the 50% samples farther away from the mean are
discarded. The mean and covariance are calculated from the remaining
samples of each group, and used as initial conditions for the GMM EM
algorithm.</p>
<p><cite>clustering_gmm</cite> internally uses <cite>GMM</cite> from the <code class="docutils literal"><span class="pre">scikit-learn</span></code>
library, with full covariance matrices for each cluster and a fixed,
uniform set of weights. This means that <cite>clustering_gmm</cite> implicitly
assumes that all bead subpopulations have roughly the same number of
events. For more information, consult <code class="docutils literal"><span class="pre">scikit-learn</span></code>&#8216;s documentation.</p>
</dd></dl>

<dl class="function">
<dt id="FlowCal.mef.fit_beads_autofluorescence">
<code class="descclassname">FlowCal.mef.</code><code class="descname">fit_beads_autofluorescence</code><span class="sig-paren">(</span><em>fl_rfi</em>, <em>fl_mef</em><span class="sig-paren">)</span><a class="headerlink" href="#FlowCal.mef.fit_beads_autofluorescence" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit a standard curve using a beads model with autofluorescence.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fl_rfi</strong> : array</p>
<blockquote>
<div><p>Fluorescence values of bead populations in units of Relative
Fluorescence Intensity (RFI).</p>
</div></blockquote>
<p><strong>fl_mef</strong> : array</p>
<blockquote>
<div><p>Fluorescence values of bead populations in MEF units.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>std_crv</strong> : function</p>
<blockquote>
<div><p>Standard curve that transforms fluorescence values from RFI to MEF
units. This function has the signature <code class="docutils literal"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">std_crv(x)</span></code>, where
<cite>x</cite> is some fluorescence value in RFI and <cite>y</cite> is the same
fluorescence expressed in MEF units.</p>
</div></blockquote>
<p><strong>beads_model</strong> : function</p>
<blockquote>
<div><p>Fluorescence model of calibration beads. This function has the
signature <code class="docutils literal"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">beads_model(x)</span></code>, where <cite>x</cite> is the fluorescence of
some bead population in RFI units and <cite>y</cite> is the same fluorescence
expressed in MEF units, without autofluorescence.</p>
</div></blockquote>
<p><strong>beads_params</strong> : array</p>
<blockquote>
<div><p>Fitted parameters of the bead fluorescence model: <code class="docutils literal"><span class="pre">[m,</span> <span class="pre">b,</span>
<span class="pre">fl_mef_auto]</span></code>.</p>
</div></blockquote>
<p><strong>beads_model_str</strong> : str</p>
<blockquote>
<div><p>String representation of the beads model used.</p>
</div></blockquote>
<p><strong>beads_params_names</strong> : list of str</p>
<blockquote class="last">
<div><p>Names of the parameters in a list, in the same order as they are
given in <cite>beads_params</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The following model is used to describe bead fluorescence:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">m</span><span class="o">*</span><span class="n">log</span><span class="p">(</span><span class="n">fl_rfi</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="n">b</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="n">fl_mef_auto</span> <span class="o">+</span> <span class="n">fl_mef</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">fl_rfi[i]</span></code> is the fluorescence of bead subpopulation <code class="docutils literal"><span class="pre">i</span></code> in
RFI units and <code class="docutils literal"><span class="pre">fl_mef[i]</span></code> is the corresponding fluorescence in MEF
units. The model includes 3 parameters: <code class="docutils literal"><span class="pre">m</span></code> (slope), <code class="docutils literal"><span class="pre">b</span></code>
(intercept), and <code class="docutils literal"><span class="pre">fl_mef_auto</span></code> (bead autofluorescence). The last term
is constrained to be greater or equal to zero.</p>
<p>The bead fluorescence model is fit in log space using nonlinear least
squares regression. In our experience, fitting in log space weights
the residuals more evenly, whereas fitting in linear space vastly
overvalues the brighter beads.</p>
<p>A standard curve is constructed by solving for <code class="docutils literal"><span class="pre">fl_mef</span></code>. As cell
samples may not have the same autofluorescence as beads, the bead
autofluorescence term (<code class="docutils literal"><span class="pre">fl_mef_auto</span></code>) is omitted from the standard
curve; the user is expected to use an appropriate white cell sample to
account for cellular autofluorescence if necessary. The returned
standard curve mapping fluorescence in RFI units to MEF units is thus
of the following form:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">fl_mef</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">m</span><span class="o">*</span><span class="n">log</span><span class="p">(</span><span class="n">fl_rfi</span><span class="p">)</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>This is equivalent to:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">fl_mef</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">fl_rfi</span><span class="o">**</span><span class="n">m</span><span class="p">)</span>
</pre></div>
</div>
<p>This works for positive <code class="docutils literal"><span class="pre">fl_rfi</span></code> values, but it is undefined for
<code class="docutils literal"><span class="pre">fl_rfi</span> <span class="pre">&lt;</span> <span class="pre">0</span></code> and non-integer <code class="docutils literal"><span class="pre">m</span></code> (general case).</p>
<p>To extend this standard curve to negative values of <code class="docutils literal"><span class="pre">fl_rfi</span></code>, we
define <code class="docutils literal"><span class="pre">s(fl_rfi)</span></code> to be equal to the standard curve above when
<code class="docutils literal"><span class="pre">fl_rfi</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code>. Next, we require this function to be odd, that is,
<code class="docutils literal"><span class="pre">s(fl_rfi)</span> <span class="pre">=</span> <span class="pre">-</span> <span class="pre">s(-fl_rfi)</span></code>. This extends the domain to negative
<code class="docutils literal"><span class="pre">fl_rfi</span></code> values and results in <code class="docutils literal"><span class="pre">s(fl_rfi)</span> <span class="pre">&lt;</span> <span class="pre">0</span></code> for any negative
<code class="docutils literal"><span class="pre">fl_rfi</span></code>. Finally, we make <code class="docutils literal"><span class="pre">fl_mef</span> <span class="pre">=</span> <span class="pre">s(fl_rfi)</span></code> our new
standard curve. In this way,:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">s</span><span class="p">(</span><span class="n">fl_rfi</span><span class="p">)</span> <span class="o">=</span>   <span class="n">exp</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span>  <span class="n">fl_rfi</span> <span class="o">**</span><span class="n">m</span><span class="p">),</span>    <span class="n">fl_rfi</span> <span class="o">&gt;=</span> <span class="mi">0</span>
            <span class="o">-</span> <span class="n">exp</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="o">-</span><span class="n">fl_rfi</span><span class="p">)</span><span class="o">**</span><span class="n">m</span><span class="p">),</span>    <span class="n">fl_rfi</span> <span class="o">&lt;</span>  <span class="mi">0</span>
</pre></div>
</div>
<p>This satisfies the definition of an odd function. In addition,
<code class="docutils literal"><span class="pre">s(0)</span> <span class="pre">=</span> <span class="pre">0</span></code>, and <code class="docutils literal"><span class="pre">s(fl_rfi)</span></code> converges to zero when <code class="docutils literal"><span class="pre">fl_rfi</span> <span class="pre">-&gt;</span> <span class="pre">0</span></code>
from both sides. Therefore, the function is continuous at
<code class="docutils literal"><span class="pre">fl_rfi</span> <span class="pre">=</span> <span class="pre">0</span></code>. The definition of <code class="docutils literal"><span class="pre">s(fl_rfi)</span></code> can be expressed more
conveniently as:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">s</span><span class="p">(</span><span class="n">fl_rfi</span><span class="p">)</span> <span class="o">=</span> <span class="n">sign</span><span class="p">(</span><span class="n">fl_rfi</span><span class="p">)</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">fl_rfi</span><span class="p">)</span><span class="o">**</span><span class="n">m</span><span class="p">)</span>
</pre></div>
</div>
<p>This is the equation implemented.</p>
</dd></dl>

<dl class="function">
<dt id="FlowCal.mef.get_transform_fxn">
<code class="descclassname">FlowCal.mef.</code><code class="descname">get_transform_fxn</code><span class="sig-paren">(</span><em>data_beads</em>, <em>mef_values</em>, <em>mef_channels</em>, <em>clustering_fxn=&lt;function clustering_gmm&gt;</em>, <em>clustering_params={}</em>, <em>clustering_channels=None</em>, <em>statistic_fxn=&lt;function median&gt;</em>, <em>statistic_params={}</em>, <em>selection_fxn=&lt;function selection_std&gt;</em>, <em>selection_params={}</em>, <em>fitting_fxn=&lt;function fit_beads_autofluorescence&gt;</em>, <em>fitting_params={}</em>, <em>verbose=False</em>, <em>plot=False</em>, <em>plot_dir=None</em>, <em>plot_filename=None</em>, <em>full_output=False</em><span class="sig-paren">)</span><a class="headerlink" href="#FlowCal.mef.get_transform_fxn" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a transformation function to convert flow cytometry data to MEF.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data_beads</strong> : FCSData object</p>
<blockquote>
<div><p>Flow cytometry data, taken from calibration beads.</p>
</div></blockquote>
<p><strong>mef_values</strong> : array</p>
<blockquote>
<div><p>Known MEF values of the calibration beads&#8217; subpopulations, for
each channel specified in <cite>mef_channels</cite>.</p>
</div></blockquote>
<p><strong>mef_channels</strong> : int, or str, or list of int, or list of str</p>
<blockquote>
<div><p>Channels for which to generate transformation functions.</p>
</div></blockquote>
<p><strong>verbose</strong> : bool, optional</p>
<blockquote>
<div><p>Flag specifying whether to print information about step completion
and warnings.</p>
</div></blockquote>
<p><strong>plot</strong> : bool, optional</p>
<blockquote>
<div><p>Flag specifying whether to produce diagnostic plots.</p>
</div></blockquote>
<p><strong>plot_dir</strong> : str, optional</p>
<blockquote>
<div><p>Directory where to save diagnostics plots. Ignored if <cite>plot</cite> is
False. If <code class="docutils literal"><span class="pre">plot==True</span></code> and <code class="docutils literal"><span class="pre">plot_dir</span> <span class="pre">is</span> <span class="pre">None</span></code>, plot without
saving.</p>
</div></blockquote>
<p><strong>plot_filename</strong> : str, optional</p>
<blockquote>
<div><p>Name to use for plot files. If None, use <code class="docutils literal"><span class="pre">str(data_beads)</span></code>.</p>
</div></blockquote>
<p><strong>full_output</strong> : bool, optional</p>
<blockquote>
<div><p>Flag specifying whether to include intermediate results in the
output. If <cite>full_output</cite> is True, the function returns a named
tuple with fields as described below. If <cite>full_output</cite> is False,
the function only returns the calculated transformation function.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>transform_fxn</strong> : function</p>
<blockquote>
<div><p>Transformation function to convert flow cytometry data from RFI
units to MEF. This function has the same basic signature as the
general transformation function specified in <code class="docutils literal"><span class="pre">FlowCal.transform</span></code>.</p>
</div></blockquote>
<p><strong>mef_channels</strong> : int, or str, or list, only if <code class="docutils literal"><span class="pre">full_output==True</span></code></p>
<blockquote>
<div><p>Channels on which transformation functions have been generated.
Directly copied from the <cite>mef_channels</cite> argument.</p>
</div></blockquote>
<p><strong>clustering</strong> : dict, only if <code class="docutils literal"><span class="pre">full_output==True</span></code></p>
<blockquote>
<div><p>Results of the clustering step, containing the following fields:</p>
<dl class="docutils">
<dt>labels <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Labels for each event in <cite>data_beads</cite>.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>statistic</strong> : dict, only if <code class="docutils literal"><span class="pre">full_output==True</span></code></p>
<blockquote>
<div><p>Results of the calculation of bead subpopulations&#8217; fluorescence,
containing the following fields:</p>
<dl class="docutils">
<dt>values <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">The representative fluorescence values of each
subpopulation, for each channel in <cite>mef_channels</cite>.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>selection</strong> : dict, only if <code class="docutils literal"><span class="pre">full_output==True</span></code></p>
<blockquote>
<div><p>Results of the subpopulation selection step, containing the
following fields:</p>
<dl class="docutils">
<dt>rfi <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">The fluorescence values of each selected subpopulation in
RFI units, for each channel in <cite>mef_channels</cite>.</p>
</dd>
<dt>mef <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">The fluorescence values of each selected subpopulation in
MEF units, for each channel in <cite>mef_channels</cite>.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>fitting</strong> : dict, only if <code class="docutils literal"><span class="pre">full_output==True</span></code></p>
<blockquote>
<div><p>Results of the model fitting step, containing the following fields:</p>
<dl class="docutils">
<dt>std_crv <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">Functions encoding the standard curves, for each channel in
<cite>mef_channels</cite>.</p>
</dd>
<dt>beads_model <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">Functions encoding the fluorescence model of the
calibration beads, for each channel in <cite>mef_channels</cite>.</p>
</dd>
<dt>beads_params <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">Fitted parameters of the bead fluorescence model, for each
channel in <cite>mef_chanels</cite>.</p>
</dd>
<dt>beads_model_str <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">String representation of the bead models used, for each channel
in <cite>mef_channels</cite>.</p>
</dd>
<dt>beads_params_names <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">Names of the parameters given in <cite>beads_params</cite>, for each
channel in <cite>mef_channels</cite>.</p>
</dd>
</dl>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Other Parameters:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body"><p class="first"><strong>clustering_fxn</strong> : function, optional</p>
<blockquote>
<div><p>Function used for clustering, or identification of subpopulations.
Must have the following signature:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">labels</span> <span class="o">=</span> <span class="n">clustering_fxn</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">n_clusters</span><span class="p">,</span> <span class="o">**</span><span class="n">clustering_params</span><span class="p">)</span>
</pre></div>
</div>
<p>where <cite>data</cite> is a NxD FCSData object or numpy array, <cite>n_clusters</cite>
is the expected number of bead subpopulations, and <cite>labels</cite> is a 1D
numpy array of length N, assigning each event in <cite>data</cite> to one
subpopulation.</p>
</div></blockquote>
<p><strong>clustering_params</strong> : dict, optional</p>
<blockquote>
<div><p>Additional keyword parameters to pass to <cite>clustering_fxn</cite>.</p>
</div></blockquote>
<p><strong>clustering_channels</strong> : list, optional</p>
<blockquote>
<div><p>Channels used for clustering. If not specified, use <cite>mef_channels</cite>.
If more than three channels are specified and <cite>plot</cite> is True, only
a 3D scatter plot will be produced using the first three channels.</p>
</div></blockquote>
<p><strong>statistic_fxn</strong> : function, optional</p>
<blockquote>
<div><p>Function used to calculate the representative fluorescence of each
subpopulation. Must have the following signature:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="n">statistic_fxn</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">statistic_params</span><span class="p">)</span>
</pre></div>
</div>
<p>where <cite>data</cite> is a 1D FCSData object or numpy array, and <cite>s</cite> is a
float. Statistical functions from numpy, scipy, or FlowCal.stats
are valid options.</p>
</div></blockquote>
<p><strong>statistic_params</strong> : dict, optional</p>
<blockquote>
<div><p>Additional keyword parameters to pass to <cite>statistic_fxn</cite>.</p>
</div></blockquote>
<p><strong>selection_fxn</strong> : function, optional</p>
<blockquote>
<div><p>Function to use for bead population selection. Must have the
following signature:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">selected_mask</span> <span class="o">=</span> <span class="n">selection_fxn</span><span class="p">(</span><span class="n">data_list</span><span class="p">,</span> <span class="o">**</span><span class="n">selection_params</span><span class="p">)</span>
</pre></div>
</div>
<p>where <cite>data_list</cite> is a list of FCSData objects, each one cotaining
the events of one population, and <cite>selected_mask</cite> is a boolean
array indicating whether the population has been selected (True) or
discarded (False). If None, don&#8217;t use a population selection
procedure.</p>
</div></blockquote>
<p><strong>selection_params</strong> : dict, optional</p>
<blockquote>
<div><p>Additional keyword parameters to pass to <cite>selection_fxn</cite>.</p>
</div></blockquote>
<p><strong>fitting_fxn</strong> : function, optional</p>
<blockquote>
<div><p>Function used to fit the beads fluorescence model and obtain a
standard curve. Must have the following signature:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">std_crv</span><span class="p">,</span> <span class="n">beads_model</span><span class="p">,</span> <span class="n">beads_params</span><span class="p">,</span> \
<span class="n">beads_model_str</span><span class="p">,</span> <span class="n">beads_params_names</span> <span class="o">=</span> <span class="n">fitting_fxn</span><span class="p">(</span>
    <span class="n">fl_rfi</span><span class="p">,</span> <span class="n">fl_mef</span><span class="p">,</span> <span class="o">**</span><span class="n">fitting_params</span><span class="p">)</span>
</pre></div>
</div>
<p>where <cite>std_crv</cite> is a function implementing the standard curve,
<cite>beads_model</cite> is a function implementing the beads fluorescence
model, <cite>beads_params</cite> is an array containing the fitted parameters
of the beads model, <cite>beads_model_str</cite> is a string representation
of the beads model used, <cite>beads_params_names</cite> is a list with the
parameter names in the same order as they are given in
<cite>beads_params</cite>, and <cite>fl_rfi</cite> and <cite>fl_mef</cite> are the fluorescence
values of the beads in RFI units and MEF units, respectively.
Note that the standard curve and the fitted beads model are not
necessarily the same.</p>
</div></blockquote>
<p><strong>fitting_params</strong> : dict, optional</p>
<blockquote class="last">
<div><p>Additional keyword parameters to pass to <cite>fitting_fxn</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The steps involved in generating the MEF transformation function are:</p>
<ol class="arabic">
<li><p class="first">The individual subpopulations of beads are first identified using a
clustering method of choice.</p>
</li>
<li><p class="first">The fluorescence of each subpopulation is calculated, for each
channel in <cite>mef_channels</cite>.</p>
</li>
<li><p class="first">Some subpopulations are then discarded if they are close to either
the minimum or the maximum channel range limits. In addition, if the
MEF value of some subpopulation is unknown (represented as a
<code class="docutils literal"><span class="pre">np.nan</span></code> in <cite>mef_values</cite>), the whole subpopulation is also</p>
<blockquote>
<div><p>discarded.</p>
</div></blockquote>
</li>
<li><p class="first">The measured fluorescence of each subpopulation is compared with
the known MEF values in <cite>mef_values</cite>, and a standard curve function
is generated using the appropriate MEF model.</p>
</li>
</ol>
<p>At the end, a transformation function is generated using the calculated
standard curves, <cite>mef_channels</cite>, and <code class="docutils literal"><span class="pre">FlowCal.transform.to_mef()</span></code>.</p>
<p>Note that applying the resulting transformation function to other
flow cytometry samples only yields correct results if they have been
taken at the same settings as the calibration beads, for all channels
in <cite>mef_channels</cite>.</p>
</dd></dl>

<dl class="function">
<dt id="FlowCal.mef.plot_standard_curve">
<code class="descclassname">FlowCal.mef.</code><code class="descname">plot_standard_curve</code><span class="sig-paren">(</span><em>fl_rfi</em>, <em>fl_mef</em>, <em>beads_model</em>, <em>std_crv</em>, <em>xscale='linear'</em>, <em>yscale='linear'</em>, <em>xlim=None</em>, <em>ylim=(1.0</em>, <em>100000000.0)</em><span class="sig-paren">)</span><a class="headerlink" href="#FlowCal.mef.plot_standard_curve" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot a standard curve with fluorescence of calibration beads.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fl_rfi</strong> : array_like</p>
<blockquote>
<div><p>Fluorescence of the calibration beads&#8217; subpopulations, in RFI
units.</p>
</div></blockquote>
<p><strong>fl_mef</strong> : array_like</p>
<blockquote>
<div><p>Fluorescence of the calibration beads&#8217; subpopulations, in MEF
units.</p>
</div></blockquote>
<p><strong>beads_model</strong> : function</p>
<blockquote>
<div><p>Fluorescence model of the calibration beads.</p>
</div></blockquote>
<p><strong>std_crv</strong> : function</p>
<blockquote>
<div><p>The standard curve, mapping relative fluorescence (RFI) units to
MEF units.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Other Parameters:</th></tr>
<tr class="field-even field"><td>&#160;</td><td class="field-body"><p class="first"><strong>xscale</strong> : str, optional</p>
<blockquote>
<div><p>Scale of the x axis, either <code class="docutils literal"><span class="pre">linear</span></code> or <code class="docutils literal"><span class="pre">log</span></code>.</p>
</div></blockquote>
<p><strong>yscale</strong> : str, optional</p>
<blockquote>
<div><p>Scale of the y axis, either <code class="docutils literal"><span class="pre">linear</span></code> or <code class="docutils literal"><span class="pre">log</span></code>.</p>
</div></blockquote>
<p><strong>xlim</strong> : tuple, optional</p>
<blockquote>
<div><p>Limits for the x axis.</p>
</div></blockquote>
<p><strong>ylim</strong> : tuple, optional</p>
<blockquote class="last">
<div><p>Limits for the y axis.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="FlowCal.mef.selection_std">
<code class="descclassname">FlowCal.mef.</code><code class="descname">selection_std</code><span class="sig-paren">(</span><em>populations</em>, <em>low=None</em>, <em>high=None</em>, <em>n_std_low=2.5</em>, <em>n_std_high=2.5</em>, <em>scale='logicle'</em><span class="sig-paren">)</span><a class="headerlink" href="#FlowCal.mef.selection_std" title="Permalink to this definition">¶</a></dt>
<dd><p>Select populations if most of their elements are between two values.</p>
<p>This function selects populations from <cite>populations</cite> if their means are
more than <cite>n_std_low</cite> standard deviations greater than <cite>low</cite> and
<cite>n_std_high</cite> standard deviations lower than <cite>high</cite>.</p>
<p>Optionally, all elements in <cite>populations</cite> can be rescaled as specified
by the <cite>scale</cite> argument before calculating means and standard
deviations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>populations</strong> : list of 1D arrays or 1-channel FCSData objects</p>
<blockquote>
<div><p>Populations to select or discard.</p>
</div></blockquote>
<p><strong>low, high</strong> : int or float</p>
<blockquote>
<div><p>Low and high thresholds. Required if the elements in <cite>populations</cite>
are numpy arrays. If not specified, and the elements in
<cite>populations</cite> are FCSData objects, use 1.5% and 98.5% of the range
in <code class="docutils literal"><span class="pre">populations[0].range</span></code>.</p>
</div></blockquote>
<p><strong>n_std_low, n_std_high</strong> : float, optional</p>
<blockquote>
<div><p>Number of standard deviations from <cite>low</cite> and <cite>high</cite>, respectively,
that a population&#8217;s mean has to be closer than to be discarded.</p>
</div></blockquote>
<p><strong>scale</strong> : str, optional</p>
<blockquote>
<div><p>Rescaling applied to <cite>populations</cite> before calculating means and
standard deviations. Can be either <code class="docutils literal"><span class="pre">linear</span></code> (no rescaling),
<code class="docutils literal"><span class="pre">log</span></code>, or <code class="docutils literal"><span class="pre">logicle</span></code>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>selected_mask</strong> : boolean array</p>
<blockquote class="last">
<div><p>Flags indicating whether a population has been selected.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="FlowCal.plot.html" class="btn btn-neutral float-right" title="FlowCal.plot module" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015, S. Castillo-Hair, J. Sexton, B. Landry, E. Olson, O. Igoshin, J. Tabor.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'1.1.4',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>